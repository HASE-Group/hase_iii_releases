
// Project:	Microcoded Processor
// Entity	Multiplexer/register unit
// File		mpx_reg.hase
// Date:	28 May 2003

// This unit has a control input, two data inputs and two data outputs.
// It multiplexes the two inputs together and sends the result to either
// or both of its two outputs.
// Multiplexer inputs are taken from inputs 1 and 2.
// Control bits:
// Bit 28 controls input1 of the multiplexer
// Bit 29 controls input2 of the multiplexer
// Bit 30 controls output1
// Bit 31 controls output2

$class_decls

//structures and variables

  int inputA, inputB, inputC;
  int mpx_input1, mpx_input2, mpx_output;
  int old_state;
  t_result_pkt result;
  int c_input, control;
  int mpx_control1, mpx_control2;

//classes

$class_defs

$pre

  control = 0;
  Reg_value = 0;
  my_state = R_IDLE;
  old_state = R_IDLE;
  dump_state();

  mpx_input1 = 0;
  mpx_input2 = 0;
  mpx_control1 = 0;
  mpx_control2 = 0;

$phase0

// predicates for use in sim_waiting test

  sim_from_port C_Input(control_input);	    
  sim_from_port InputA(input1);	    
  sim_from_port InputB(input2);	    

    // DEAL WITH INPUT

  if  (sim_waiting(C_Input) > 0)
     {
	sim_select (C_Input, ev);
	SIM_CAST_DEL(int, c_input, ev);
	control = c_input & 15;
     }


  if  (sim_waiting(InputA) > 0)
     {
	sim_select (InputA, ev);
	SIM_CAST_DEL( int, inputA, ev);
	mpx_input1 = inputA;
     }

  if  (sim_waiting(InputB) > 0)
     {
	sim_select (InputB, ev);
	SIM_CAST_DEL( int, inputB, ev);
	mpx_input2 = inputB;
     }


// set mpx and adder input control bits

  mpx_control1   = 0 - ((control & 8) >> 3);
  mpx_control2   = 0 - ((control & 4) >> 2);

// OR together mpx inputs to form output

  mpx_output = (mpx_input1 & mpx_control1) | (mpx_input2 & mpx_control2);

// load Register if either input control bit is 1

  if (((control & 8) == 8) || ((control & 4) == 4))
	{Reg_value = mpx_output;}

  result.value = Reg_value;
  dump_state_i();

	// end of ClockPhase = 0

$phase1


// If output1 control bit = 1, send result to output 1

 if ((control & 2) == 2)
	  {send_RESULT(output1, result);}

// If output2 control bit = 1, send result to output 2

 if ((control & 1) == 1)
	  {send_RESULT(output2, result);}
  control = 0;

	// end of  ClockPhase 1



