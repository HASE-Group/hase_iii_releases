
// Project:	Microcoded Processor
// Entity	Multiplexer/adder/register unit
// File		mpx_add_reg.hase
// Date:	28 May 2003

// This unit has a control input, three data inputs and two data outputs.
// It multiplexes two of the inputs together, adds the result to the third
// and sends the result to either or both of its two outputs.
// Multiplexer inputs are taken from inputs 1 and 2 of the unit
// Input 1 is permanently set to +1. The +1 entities are just for show!
// Output 1 is assumed to be connected back to input 3 and sends a
// result whenever any of the input controls is 1.
// Output 2 is assumed to be connectable to a bus so it is controlled
// by one of the control bits.


// Control word:
// Bit 28 controls input1 of the multiplexer (+1)
// Bit 29 controls input2 of the multiplexer (from ucode unit)
// Bit 30 controls input3 (from own output)
// Bit 31 controls output2 (to ucode unit)

$class_decls


//structures and variables

  char myname[4];

  bool reg_value_updated;

  int inputA, inputB, inputC;
  int mpx_input1, mpx_input2;
  int adder_input1, adder_input2, adder_output;
  int old_state;
  int c_input, control;
  int mpx_control1, mpx_control2, adder_control1;

  int result;

//classes

$class_defs


$pre

  reg_value_updated = false;
  Reg_value = 0;
  my_state = R_IDLE;
  old_state = R_IDLE;
  dump_state();
  control = 0;
  mpx_input1 = 0;
  mpx_input2 = 0;
  mpx_control1 = 0;
  mpx_control2 = 0;
  adder_input1 = 0;
  adder_input2 = 0;
  adder_output = 0;
  adder_control1 = 0;

  if (strcmp(get_name(), "MPC") == 0)
	{strcpy(myname, "MPC");}
	 
  if (strcmp(get_name(), "PC") == 0)
	{strcpy(myname, "PC");}

$phase0

// predicates for use in sim_waiting test

  sim_from_port C_Input(control_input);	    
  sim_from_port InputA(input1);	    	// +1
  sim_from_port InputB(input2);	  	// external input  
  sim_from_port InputC(input3);	    	// from own register


    // DEAL WITH INPUT

  if  (sim_waiting(ev, C_Input) > 0)
     {
	SIM_CAST_DEL(int, c_input, ev);
	control = c_input & 15;
     }

// set unit busy if either of its output control bits is 1
// and set void/active state in display

  if ((control & 14) > 0)	// one of the inputs is active

	  {my_state = R_BUSY;}
	else
	  {my_state = R_IDLE;}


  if  (sim_waiting(ev, InputA) > 0)	// not used in practice since
					// mpx_input1 is set to 1 lower down
     {
	SIM_CAST_DEL( int, inputA, ev);
	adder_input1 = inputA;
     }

  if  (sim_waiting(ev, InputB) > 0)
     {
	SIM_CAST_DEL( int, inputB, ev);
	mpx_input1 = inputB;
     }


  if  (sim_waiting(ev, InputC) > 0)
     {
	SIM_CAST_DEL( int, inputC, ev);
	mpx_input2 = inputC;
     }

// set mpx input 1 to 1

  mpx_input1 = 1;

// set mpx and adder input control bits

  adder_control1 = 0 - ((control & 8) >> 3); // i.e. all 1s if control bit = 1
  mpx_control1   = 0 - ((control & 4) >> 2);
  mpx_control2   = 0 - ((control & 2) >> 1);


// OR together mpx inputs to form second adder input

  adder_input2 = (mpx_input1 & mpx_control1) | (mpx_input2 & mpx_control2);

// perform add

  adder_output = (adder_input1 & adder_control1) + adder_input2;

// load Register

  if (my_state == R_BUSY)
	{
	  Reg_value = adder_output;
	  reg_value_updated = true;
	  result = Reg_value;
	}
  if ((my_state != old_state) || reg_value_updated)
	  {dump_state();
	   old_state = my_state;
	   reg_value_updated = false;
	  }

	// end of ClockPhase = 0

$phase1


// If busy, send result to output 1

 if (my_state == R_BUSY)
	  {send_RESULT(output1, result);

}

// If output2 control bit = 1, send result to output 2

 if ((control & 1) == 1)
	  {send_RESULT(output2, result);}

  control = 0;

	// end of  ClockPhase 1









